;
; Copyright (c) Hand Held Legend, LLC 2023
;

.program joybus

; Repeatedly get one word of data from the TX FIFO, stalling when the FIFO is
; empty. Write the least significant bit to the OUT pin group.

.wrap_target
; First lets focus on counting pulses
PUBLIC joybusin:
  set pindirs, 0
  set pins, 1 ; set HI
  mov isr, NULL
bytestart:
  set x, 7 ; Set x scratch register as bit counter to allow 8 loops
bitloop:
  wait 1 pin, 0     ; Wait for line HIGH
  wait 0 pin, 0 [7]
  nop
  ; Get the level and put it into ISR
  in pins, 1
  ; Decrement x and jump to bitloop if we aren't at 0 yet
  jmp x-- bitloop
completed:
  ; Set interrupt, do not wait for it to clear
  irq nowait 0
  jmp bytestart

PUBLIC joybusout:
    set pindirs, 0 ; SET Hi-Z INPUT
    set pins, 0 ; set LOW
output:
    out x, 1        ; 1 cycle - Get bit 
    set pindirs, 1  ; 1 cycle - set OUTPUT LOW
    nop
    jmp !x do_zero  ; 1 cycle - Branch if zero
do_one:
    nop              ; 1 cycle 
    set pindirs, 0 [8]  ; 10 cycles - set HIGH
    jmp do_end_check ; 1 cycle
do_zero:
    nop [8]
    set pindirs, 0 [1] ; 3 cycles HIGH
do_end_check:
    jmp !osre output ; 1 cycle HIGH or LOW
    nop
    set pindirs, 1 [7] ; 8 cycles LOW (2μs) ✓
    set pindirs, 0 [7] ; 8 cycles HIGH (2μs) ✓
    ;irq nowait 1
    jmp joybusin
.wrap

% c-sdk {
#include "hardware/clocks.h"

static inline void joybus_jump_output(PIO pio, uint sm, uint offset)
{
    pio_sm_exec(pio, sm, pio_encode_jmp(offset + joybus_offset_joybusout));
}

static inline void joybus_program_reset(PIO pio, uint sm, uint offset)
{
    pio_sm_set_enabled(pio, sm, false);
    pio_sm_clear_fifos(pio, sm);
    pio_sm_exec(pio, sm, pio_encode_jmp(offset + joybus_offset_joybusin));
    pio_sm_set_enabled(pio, sm, true);
}

static inline void joybus_program_init(PIO pio, uint sm, uint offset, uint pin, pio_sm_config *c) {
    
    *c = joybus_program_get_default_config(offset);

    //gpio_init(pin);

    // Set this pin's GPIO function (connect PIO to the pad)
    pio_gpio_init(pio, pin);

    //sm_config_set_jmp_pin(c, pin);

    // Must run 12800000hz
    float div = clock_get_hz(clk_sys) / (4000000);
    sm_config_set_clkdiv(c, div);

    // Set sideset pin
    //sm_config_set_sideset_pins(c, pin);

    // Configure IN pins (for in pins instruction)
    sm_config_set_in_pins(c, pin);

    // Configure SET pins
    sm_config_set_set_pins(c, pin, 1);
    
    // Configure OUT pins (optional but good practice)
    sm_config_set_out_pins(c, pin, 1);

    sm_config_set_in_shift(c, false, true, 8);
    sm_config_set_out_shift(c, false, true, 8);

    // Load our configuration, and jump to the start of the program
    pio_sm_init(pio, sm, offset, c);

    // Set the state machine running
    pio_sm_set_enabled(pio, sm, true);
}
%}