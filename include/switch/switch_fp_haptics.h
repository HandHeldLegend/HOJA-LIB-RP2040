#ifndef SWITCH_FP_HAPTICS_H
#define SWITCH_FP_HAPTICS_H

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

typedef enum
{
    Action_Ignore     = 0x0,
    Action_Default    = 0x1,
    Action_Substitute = 0x2,
    Action_Sum        = 0x3,
} AmFmAction_t;

typedef struct
{
    AmFmAction_t am_action : 8;
    AmFmAction_t fm_action : 8;
    uint16_t am_offset;
    uint16_t fm_offset;
} AmFm5BitCommand_s;

typedef struct {
    // Value representing phase increment (80Hz to 1280Hz)
    uint16_t freq_hi;
    
    // Value representing phase increment (40Hz to 640Hz) 
    uint16_t freq_lo;
    
    // High amplitude in Q16.16 fixed point 
    uint16_t amp_hi;
    
    // Low amplitude in Q16.16 fixed point
    uint16_t amp_lo;
} amfm_s;

// Original frequency formula from RumbleFreqLookup:
// freq_linear = 0.03125f * i - 2.0f
// Then this goes through exp2f()
// Then multiplied by 320 (for high freq)
// Then converted to fixed point Q8.8

/*
    for(int i = 0; i < 128; i++) {
        // Calculate the linear value first
        double linear = 0.03125 * i - 2.0;
        
        // Apply exp2 transform and scale by center freq
        double freq = 320.0 * pow(2.0, linear);
        
        // Convert to Q8.8 fixed point (multiply by 256)
        uint16_t fixed_point = (uint16_t)(freq * 256.0 + 0.5); // +0.5 for rounding
        
        // Print in a nice format
        printf("0x%04X", fixed_point);
        
        // Format the output nicely
        if(i < 127) printf(", ");
        if((i + 1) % 8 == 0) printf("\n    ");
    }
*/

const uint16_t freq_table_hi[128] = {
    0x5000, 0x51C0, 0x538B, 0x555F, 0x573E, 0x5927, 0x5B1A, 0x5D19, 
    0x5F23, 0x6138, 0x6359, 0x6586, 0x67BF, 0x6A05, 0x6C57, 0x6EB6, 
    0x7123, 0x739D, 0x7625, 0x78BC, 0x7B60, 0x7E14, 0x80D7, 0x83A9, 
    0x868B, 0x897D, 0x8C80, 0x8F94, 0x92B8, 0x95EF, 0x9937, 0x9C92, 
    0xA000, 0xA381, 0xA715, 0xAABE, 0xAE7B, 0xB24D, 0xB635, 0xBA32, 
    0xBE46, 0xC271, 0xC6B2, 0xCB0C, 0xCF7F, 0xD40A, 0xD8AE, 0xDD6D, 
    0xE246, 0xE73B, 0xEC4B, 0xF177, 0xF6C1, 0xFC28, 0x01AE, 0x0752, 
    0x0D16, 0x12FB, 0x1900, 0x1F27, 0x2571, 0x2BDE, 0x326F, 0x3925, 
    0x4000, 0x4702, 0x4E2B, 0x557C, 0x5CF6, 0x649B, 0x6C6A, 0x7464, 
    0x7C8C, 0x84E1, 0x8D65, 0x9619, 0x9EFD, 0xA813, 0xB15D, 0xBADA, 
    0xC48C, 0xCE75, 0xD896, 0xE2EF, 0xED82, 0xF850, 0x035B, 0x0EA4, 
    0x1A2C, 0x25F5, 0x3200, 0x3E4F, 0x4AE2, 0x57BC, 0x64DE, 0x7249, 
    0x8000, 0x8E04, 0x9C56, 0xAAF8, 0xB9ED, 0xC935, 0xD8D3, 0xE8C9, 
    0xF918, 0x09C2, 0x1ACA, 0x2C31, 0x3DFA, 0x5027, 0x62B9, 0x75B4, 
    0x8919, 0x9CEA, 0xB12B, 0xC5DD, 0xDB04, 0xF0A1, 0x06B7, 0x1D49, 
    0x3459, 0x4BEB, 0x6400, 0x7C9D, 0x95C4, 0xAF78, 0xC9BB, 0xE492
};

// Original frequency formula from RumbleFreqLookup:
// freq_linear = 0.03125f * i - 2.0f
// Then this goes through exp2f()
// Then multiplied by 160 (for low freq)
// Then converted to fixed point Q8.8

/*
    for(int i = 0; i < 128; i++) {
        // Calculate the linear value
        double linear = 0.03125 * i - 2.0;
        
        // Apply exp2 transform and scale by center freq
        double freq = 160.0 * pow(2.0, linear);
        
        // Convert to Q8.8 fixed point (multiply by 256)
        uint16_t fixed_point = (uint16_t)(freq * 256.0 + 0.5); // +0.5 for rounding
        
        // Print in a nice format
        printf("0x%04X", fixed_point);
        
        // Format the output nicely
        if(i < 127) printf(", ");
        if((i + 1) % 8 == 0) printf("\n    ");
    }
*/

const uint16_t freq_table_lo[128] = {
    0x2800, 0x28E0, 0x29C5, 0x2AB0, 0x2B9F, 0x2C93, 0x2D8D, 0x2E8D, 
    0x2F91, 0x309C, 0x31AD, 0x32C3, 0x33E0, 0x3502, 0x362C, 0x375B, 
    0x3892, 0x39CF, 0x3B13, 0x3C5E, 0x3DB0, 0x3F0A, 0x406B, 0x41D5, 
    0x4346, 0x44BF, 0x4640, 0x47CA, 0x495C, 0x4AF7, 0x4C9C, 0x4E49, 
    0x5000, 0x51C0, 0x538B, 0x555F, 0x573E, 0x5927, 0x5B1A, 0x5D19, 
    0x5F23, 0x6138, 0x6359, 0x6586, 0x67BF, 0x6A05, 0x6C57, 0x6EB6, 
    0x7123, 0x739D, 0x7625, 0x78BC, 0x7B60, 0x7E14, 0x80D7, 0x83A9, 
    0x868B, 0x897D, 0x8C80, 0x8F94, 0x92B8, 0x95EF, 0x9937, 0x9C92, 
    0xA000, 0xA381, 0xA715, 0xAABE, 0xAE7B, 0xB24D, 0xB635, 0xBA32, 
    0xBE46, 0xC271, 0xC6B2, 0xCB0C, 0xCF7F, 0xD40A, 0xD8AE, 0xDD6D, 
    0xE246, 0xE73B, 0xEC4B, 0xF177, 0xF6C1, 0xFC28, 0x01AE, 0x0752, 
    0x0D16, 0x12FB, 0x1900, 0x1F27, 0x2571, 0x2BDE, 0x326F, 0x3925, 
    0x4000, 0x4702, 0x4E2B, 0x557C, 0x5CF6, 0x649B, 0x6C6A, 0x7464, 
    0x7C8C, 0x84E1, 0x8D65, 0x9619, 0x9EFD, 0xA813, 0xB15D, 0xBADA, 
    0xC48C, 0xCE75, 0xD896, 0xE2EF, 0xED82, 0xF850, 0x035B, 0x0EA4, 
    0x1A2C, 0x25F5, 0x3200, 0x3E4F, 0x4AE2, 0x57BC, 0x64DE, 0x7249
};

// Original amplitude lookup had these pieces:
// if (i == 0) -> -8.0
// else if (i < 16) -> 0.25 * i - 7.75
// else if (i < 32) -> 0.0625 * i - 4.9375
// else -> 0.03125 * i - 3.96875
// These values then go through exp2f()
// Then convert to Q0.16 fixed point

/*
    for(int i = 0; i < 128; i++) {
        // Get linear value based on piecewise function
        double linear = get_amp_linear(i);
        
        // Apply exp2 transform
        double amplitude = pow(2.0, linear);
        
        // Convert to Q0.16 fixed point (multiply by 65536)
        uint16_t fixed_point = (uint16_t)(amplitude * 65536.0 + 0.5); // +0.5 for rounding
        
        // Print in a nice format
        printf("0x%04X", fixed_point);
        
        // Format the output nicely
        if(i < 127) printf(", ");
        if((i + 1) % 8 == 0) printf("\n    ");
    }
*/

/*
const uint16_t amp_table[128] = {
    0x0100, 0x016A, 0x01AF, 0x0200, 0x0261, 0x02D4, 0x035D, 0x0400, 
    0x04C2, 0x05A8, 0x06BA, 0x0800, 0x0983, 0x0B50, 0x0D74, 0x1000, 
    0x10B5, 0x1173, 0x1238, 0x1307, 0x13DF, 0x14C0, 0x15AB, 0x16A1, 
    0x17A1, 0x18AD, 0x19C5, 0x1AE9, 0x1C1A, 0x1D58, 0x1EA5, 0x2000, 
    0x20B3, 0x216B, 0x2226, 0x22E5, 0x23A9, 0x2471, 0x253D, 0x260E, 
    0x26E3, 0x27BD, 0x289C, 0x2980, 0x2A68, 0x2B56, 0x2C49, 0x2D41, 
    0x2E3F, 0x2F42, 0x304B, 0x315A, 0x326E, 0x3389, 0x34AA, 0x35D1, 
    0x36FF, 0x3833, 0x396E, 0x3AB0, 0x3BF9, 0x3D49, 0x3EA1, 0x4000, 
    0x4167, 0x42D5, 0x444C, 0x45CB, 0x4752, 0x48E2, 0x4A7A, 0x4C1C, 
    0x4DC7, 0x4F7B, 0x5138, 0x52FF, 0x54D1, 0x56AC, 0x5892, 0x5A82, 
    0x5C7E, 0x5E84, 0x6096, 0x62B4, 0x64DD, 0x6712, 0x6954, 0x6BA2, 
    0x6DFE, 0x7066, 0x72DD, 0x7560, 0x77F2, 0x7A93, 0x7D42, 0x8000, 
    0x82CE, 0x85AB, 0x8898, 0x8B96, 0x8EA4, 0x91C4, 0x94F5, 0x9838, 
    0x9B8D, 0x9EF5, 0xA270, 0xA5FF, 0xA9A1, 0xAD58, 0xB124, 0xB505, 
    0xB8FC, 0xBD09, 0xC12C, 0xC567, 0xC9BA, 0xCE25, 0xD2A8, 0xD745, 
    0xDBFC, 0xE0CD, 0xE5B9, 0xEAC1, 0xEFE5, 0xF525, 0xFA84, 0x0000  
};
*/


#endif