// Notes for Series Controller USB comms
// 3 interfaces
// Device Descriptor

{
=======
#include <stdint.h>
// 3 interfaces
// Device Descriptor

uint8_t device_desc[] = {
    0x12,       // bLength
    0x01,       // bDescriptorType (Device)
    0x00, 0x02, // bcdUSB 2.00
    0xFF,       // bDeviceClass
    0x47,       // bDeviceSubClass
    0xD0,       // bDeviceProtocol
    0x40,       // bMaxPacketSize0 64
    0x5E, 0x04, // idVendor 0x045E
    0x12, 0x0B, // idProduct 0x0B12
    0x11, 0x05, // bcdDevice 10.11
    0x01,       // iManufacturer (String Index)
    0x02,       // iProduct (String Index)
    0x03,       // iSerialNumber (String Index)
    0x01,       // bNumConfigurations 1
    // 18 bytes
}



// Config Descriptor
uint8_t config_desc[] = {
    0x09,           // bLength
        0x02,       // bDescriptorType (Configuration)
        0x77, 0x00, // wTotalLength 119
        0x03,       // bNumInterfaces 3
        0x01,       // bConfigurationValue
        0x00,       // iConfiguration (String Index)
        0xA0,       // bmAttributes Remote Wakeup
        0xFA,       // bMaxPower 500mA

        0x09, // bLength
        0x04, // bDescriptorType (Interface)
        0x00, // bInterfaceNumber 0
        0x00, // bAlternateSetting
        0x02, // bNumEndpoints 2
        0xFF, // bInterfaceClass
        0x47, // bInterfaceSubClass
        0xD0, // bInterfaceProtocol
        0x00, // iInterface (String Index)

        0x07,       // bLength
        0x05,       // bDescriptorType (Endpoint)
        0x02,       // bEndpointAddress (OUT/H2D)
        0x03,       // bmAttributes (Interrupt)
        0x40, 0x00, // wMaxPacketSize 64
        0x04,       // bInterval 4 (unit depends on device speed)

        0x07,       // bLength
        0x05,       // bDescriptorType (Endpoint)
        0x82,       // bEndpointAddress (IN/D2H)
        0x03,       // bmAttributes (Interrupt)
        0x40, 0x00, // wMaxPacketSize 64
        0x04,       // bInterval 4 (unit depends on device speed)

        0x09, // bLength
        0x04, // bDescriptorType (Interface)
        0x00, // bInterfaceNumber 0
        0x01, // bAlternateSetting
        0x02, // bNumEndpoints 2
        0xFF, // bInterfaceClass
        0x47, // bInterfaceSubClass
        0xD0, // bInterfaceProtocol
        0x00, // iInterface (String Index)

        0x07,       // bLength
        0x05,       // bDescriptorType (Endpoint)
        0x02,       // bEndpointAddress (OUT/H2D)
        0x03,       // bmAttributes (Interrupt)
        0x40, 0x00, // wMaxPacketSize 64
        0x04,       // bInterval 4 (unit depends on device speed)

        0x07,       // bLength
        0x05,       // bDescriptorType (Endpoint)
        0x82,       // bEndpointAddress (IN/D2H)
        0x03,       // bmAttributes (Interrupt)
        0x40, 0x00, // wMaxPacketSize 64
        0x02,       // bInterval 2 (unit depends on device speed)

        0x09, // bLength
        0x04, // bDescriptorType (Interface)
        0x01, // bInterfaceNumber 1
        0x00, // bAlternateSetting
        0x00, // bNumEndpoints 0
        0xFF, // bInterfaceClass
        0x47, // bInterfaceSubClass
        0xD0, // bInterfaceProtocol
        0x00, // iInterface (String Index)

        0x09, // bLength
        0x04, // bDescriptorType (Interface)
        0x01, // bInterfaceNumber 1
        0x01, // bAlternateSetting
        0x02, // bNumEndpoints 2
        0xFF, // bInterfaceClass
        0x47, // bInterfaceSubClass
        0xD0, // bInterfaceProtocol
        0x00, // iInterface (String Index)

        0x07,       // bLength
        0x05,       // bDescriptorType (Endpoint)
        0x03,       // bEndpointAddress (OUT/H2D)
        0x01,       // bmAttributes (Isochronous, No Sync, Data EP)
        0xE4, 0x00, // wMaxPacketSize 228
        0x01,       // bInterval 1 (unit depends on device speed)

        0x07,       // bLength
        0x05,       // bDescriptorType (Endpoint)
        0x83,       // bEndpointAddress (IN/D2H)
        0x01,       // bmAttributes (Isochronous, No Sync, Data EP)
        0x40, 0x00, // wMaxPacketSize 64
        0x01,       // bInterval 1 (unit depends on device speed)

        0x09, // bLength
        0x04, // bDescriptorType (Interface)
        0x02, // bInterfaceNumber 2
        0x00, // bAlternateSetting
        0x00, // bNumEndpoints 0
        0xFF, // bInterfaceClass
        0x47, // bInterfaceSubClass
        0xD0, // bInterfaceProtocol
        0x00, // iInterface (String Index)

        0x09, // bLength
        0x04, // bDescriptorType (Interface)
        0x02, // bInterfaceNumber 2
        0x01, // bAlternateSetting
        0x02, // bNumEndpoints 2
        0xFF, // bInterfaceClass
        0x47, // bInterfaceSubClass
        0xD0, // bInterfaceProtocol
        0x00, // iInterface (String Index)

        0x07,       // bLength
        0x05,       // bDescriptorType (Endpoint)
        0x04,       // bEndpointAddress (OUT/H2D)
        0x02,       // bmAttributes (Bulk)
        0x40, 0x00, // wMaxPacketSize 64
        0x00,       // bInterval 0 (unit depends on device speed)

        0x07,       // bLength
        0x05,       // bDescriptorType (Endpoint)
        0x84,       // bEndpointAddress (IN/D2H)
        0x02,       // bmAttributes (Bulk)
        0x40, 0x00, // wMaxPacketSize 64
        0x00,       // bInterval 0 (unit depends on device speed)

    // 119 bytes
};

// Connection procedure

/** 
 * 1. After configuration response is received from SET
 * packets of zero length are sent in to endpoint 0x82
 * 
 * 2. A packet of length 32 is sent from the controller to the PC
 * This seems to contain a MAC address, the firmware version, and some other data
 **/

typedef struct
{
    uint8_t report_id; // 0x02
    uint8_t unknown_mac_address_more[15];
    uint8_t version_low[2];     // 0x05, 0x00 LE formatting (5.17.3202.0)
    uint8_t version_middle[2];  // 0x11, 0x00 LE
    uint8_t version_third[2];   // 0x0C, 0x82 LE
    uint8_t version_fourth[2];  // 0x00, 0x00
    uint8_t unknown[8]; // no idea
} announce_message_s;

// Host sends a 0x04 message
uint8_t sent0[] = {0x04, 0x20, 0x01, 0x00};

// Controller immediately responds with a lot of different data...
// This is described by some as the device descriptor specifically
// for GIP devices 

// First response device -> host
// 64 bytes
uint8_t response1[] = {0x04, 0xf0, 0x02, 0x3a, 0xec,
0x01, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xec,
0x00, 0xad, 0x00, 0x16, 0x00, 0x1b, 0x00, 0x1c, 0x00, 0x26, 0x00, 0x2f, 0x00, 0x4c, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x05, 0x00, 0x11, 0x00, 0x00, 0x09, 0x01, 0x02,
0x03, 0x04, 0x06, 0x07, 0x0c, 0x0d, 0x1e, 0x08, 0x01, 0x04, 0x05};

// Host sends packet to device
uint8_t sent1[] = {0x01, 0x20, 0x02, 0x09, 0x00, 0x04, 0x20, 
0x3a, 0x00, 0x00, 0x00, 0xb2, 0x00};

// Device responds to host
// 64 bytes
// Contains the string "Windows Xbox Input Gamepad" followed by unknown data
uint8_t response2[] =   {0x04, 0xa0, 0x02, 0xba, 0x00,
// end header
0x3a, 0x06, 0x0a, 0x0c, 0x0d, 0x1e, 0x01, 0x1a, 0x00, 0x57, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x73,
0x2e, 0x58, 0x62, 0x6f, 0x78, 0x2e, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x2e, 0x47, 0x61, 0x6d, 0x65,
0x70, 0x61, 0x64, 0x06, 0x56, 0xff, 0x76, 0x97, 0xfd, 0x9b, 0x81, 0x45, 0xad, 0x45, 0xb6, 0x45,
0xbb, 0xa5, 0x26, 0xd6, 0x2c, 0x40, 0x2e, 0x08, 0xdf, 0x07, 0xe1};

uint8_t response3[] = {0x04, 0xa0, 0x02, 0xba, 0x00,
// end header
0x74, 0x45, 0xa5, 0xab, 0xa3, 0x12, 0x7a, 0xf1, 0x97, 0xb5, 0xe7, 0x1f, 0xf3, 0xb8, 0x86, 0x73,
0xe9, 0x40, 0xa9, 0xf8, 0x2f, 0x21, 0x26, 0x3a, 0xcf, 0xb7, 0xfe, 0xd2, 0xdd, 0xec, 0x87, 0xd3,
0x94, 0x42, 0xbd, 0x96, 0x1a, 0x71, 0x2e, 0x3d, 0xc7, 0x7d, 0x6b, 0xe5, 0xf2, 0x87, 0xbb, 0xc3,
0xb1, 0x49, 0x82, 0x65, 0xff, 0xff, 0xf3, 0x77, 0x99, 0xee, 0x1e
};

uint8_t response4[] = {0x04, 0xa0, 0x02, 0x3a, 0xae,
// end header
0x01, 0x9b, 0xad, 0x34, 0xad, 0x36, 0xb5, 0x4f, 0x8a, 0xc7, 0x17, 0x23, 0x4c, 0x9f, 0x54, 0x6f,
0x02, 0x17, 0x00, 0x20, 0x2c, 0x00, 0x01, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x00, 0x09, 0x3c, 0x00, 0x01, 0x00, 0x08,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

uint8_t response5[] = {0x04, 0xb0, 0x02, 0x04, 0xe8,
// end header
0x01, 0x00, 0x00, 0x00, 0x00
};
